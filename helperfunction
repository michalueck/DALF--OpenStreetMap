import re  
import audit  
import schema  
SCHEMA = schema.schema  
import codecs  
import cerberus  
import csv  
import xml.etree.cElementTree as ET #we use the C version of ElementTree as the file is pretty big  
import pprint  
  
#Creation of CSV files for the SQL database  
NODES_CSV="nodes.csv"  
NODES_TAGS_CSV="nodes_tags.csv"  
WAYS_CSV="ways.csv"  
WAYS_TAGS_CSV="ways_tags.csv"  
WAYS_NODES_CSV="ways_nodes.csv"  
  
#Specific Char  
LOWER_COLON = re.compile(r'^([a-z]|_)*:([a-z]|_)*$')  
  
# Make sure the fields order in the csvs matches the column order in the sql table schema  
NODE_FIELDS = ['id', 'lat', 'lon', 'user', 'uid', 'version', 'changeset', 'timestamp']  
NODE_TAGS_FIELDS = ['id', 'key', 'value', 'type']  
WAY_FIELDS = ['id', 'user', 'uid', 'version', 'changeset', 'timestamp']  
WAY_TAGS_FIELDS = ['id', 'key', 'value', 'type']  
WAY_NODES_FIELDS = ['id', 'node_id', 'position']  
  
  
  
def shape_element(element, node_attr_fields=NODE_FIELDS, way_attr_fields=WAY_FIELDS, default_tag_type='regular'):  
    """Clean and shape node or way XML element to Python dict"""  
  
    node_attribs = {}  
    way_attribs = {}  
    way_nodes = []  
    tags = []    
  
    if element.tag == 'node':  
        for iterator in element.iter('tag'):  
            node_tag = {}  
            if LOWER_COLON.match(iterator.attrib['k']):  
                node_tag['type'] = iterator.attrib['k'].split(':',1)[0]  
                node_tag['key'] = iterator.attrib['k'].split(':',1)[1]  
                node_tag['id'] = element.attrib['id']  
                if node_tag['key']=="street":  
                    node_tag['value'] = audit.update_name(iterator.attrib['v'],audit.mapping)  
                elif node_tag['key']=="postcode":  
                    node_tag['value'] = audit.update_postcode(iterator.attrib['v'],audit.mapping_post)  
                else:  
                    node_tag['value'] = iterator.attrib['v']       
            else:  
                node_tag['type'] = "regular"  
                node_tag['key'] = iterator.attrib['k']  
                node_tag['value'] = iterator.attrib['v']  
                node_tag['id'] = element.attrib['id']  
    
            tags.append(node_tag)  
                      
        return {'node': node_attribs, 'node_tags': tags}  
          
    elif element.tag == 'way':             
        position = 0  
        for iterator in element:  
            way_tag = {}  
            way_node = {}  
              
            if iterator.tag == 'tag':  
                if LOWER_COLON.match(iterator.attrib['k']):  
                    way_tag['type'] = iterator.attrib['k'].split(':',1)[0]  
                    way_tag['key'] = iterator.attrib['k'].split(':',1)[1]  
                    way_tag['id'] = element.attrib['id']  
                    if way_tag['key']=='street':  
                        way_tag['value'] = audit.update_name(iterator.attrib['v'],audit.mapping)  
                    elif way_tag['key']=="postcode":  
                        way_tag['value'] = audit.update_postcode(iterator.attrib['v'],audit.mapping_post)  
                    else:                          
                        way_tag['value'] = iterator.attrib['v']  
                else:  
                    way_tag['type'] = 'regular'  
                    way_tag['key'] = iterator.attrib['k']  
                    way_tag['id'] = element.attrib['id']  
                    way_tag['value'] = iterator.attrib['v']  
  
                tags.append(way_tag)  
  
                      
            elif iterator.tag == 'nd':  
                way_node['id'] = element.attrib['id']  
                way_node['node_id'] = iterator.attrib['ref']  
                way_node['position'] = position  
                position += 1  
                way_nodes.append(way_node)  
          
            return {'way': way_attribs, 'way_nodes': way_nodes, 'way_tags': tags}  
          
        # ================================================== #  
        #               Helper Functions                     #  
        # ================================================== #  
        def get_element(osm_file, tags=('node', 'way', 'relation')):  
            """Yield element if it is the right type of tag"""  
          
            context = ET.iterparse(osm_file, events=('start', 'end'))  
            _, root = next(context)  
            for event, elem in context:  
                if event == 'end' and elem.tag in tags:  
                    yield elem  
                    root.clear()  
          
        def validate_element(element, validator, schema=SCHEMA):  
            """Raise ValidationError if element does not match schema"""  
            if validator.validate(element, schema) is not True:  
                field, errors = next(validator.errors.iteritems())  
                message_string = "\nElement of type '{0}' has the following errors:\n{1}"  
                error_string = pprint.pformat(errors)       
                raise Exception(message_string.format(field, error_string))  
          
        class UnicodeDictWriter(csv.DictWriter, object):  
            """Extend csv.DictWriter to handle Unicode input"""  
            def writerow(self, row):  
                super(UnicodeDictWriter, self).writerow({  
                k: (v.encode('utf-8') if isinstance(v, unicode) else v) for k, v in row.iteritems()  
                })  
            def writerows(self, rows):  
                for row in rows:  
                    self.writerow(row)  
                      
        # ================================================== #  
        #               Main Function                        #  
        # ================================================== #  
        def process_map(file_in, validate):  
            """Iteratively process each XML element and write to csv(s)"""  
          
            with codecs.open(NODES_CSV, 'w') as nodes_file, \  
                 codecs.open(NODES_TAGS_CSV, 'w') as nodes_tags_file, \  
                 codecs.open(WAYS_CSV, 'w') as ways_file, \  
                 codecs.open(WAYS_NODES_CSV, 'w') as way_nodes_file, \  
                 codecs.open(WAYS_TAGS_CSV, 'w') as way_tags_file:  
          
                nodes_writer = UnicodeDictWriter(nodes_file, NODE_FIELDS)  
                node_tags_writer = UnicodeDictWriter(nodes_tags_file, NODE_TAGS_FIELDS)  
                ways_writer = UnicodeDictWriter(ways_file, WAY_FIELDS)  
                way_nodes_writer = UnicodeDictWriter(way_nodes_file, WAY_NODES_FIELDS)  
                way_tags_writer = UnicodeDictWriter(way_tags_file, WAY_TAGS_FIELDS)  
          
                nodes_writer.writeheader()  
                node_tags_writer.writeheader()  
                ways_writer.writeheader()  
                way_nodes_writer.writeheader()  
                way_tags_writer.writeheader()  
          
                validator = cerberus.Validator()  
          
                for element in get_element(file_in, tags=('node', 'way')):  
                    el = shape_element(element)  
                    if el:  
                        if validate is True:  
                            validate_element(el, validator)  
          
                        if element.tag == 'node':  
                            nodes_writer.writerow(el['node'])  
                            node_tags_writer.writerows(el['node_tags'])  
                        elif element.tag == 'way':  
                            ways_writer.writerow(el['way'])  
                            way_nodes_writer.writerows(el['way_nodes'])  
                            way_tags_writer.writerows(el['way_tags'])  
 